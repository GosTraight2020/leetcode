**1.什么是内存泄露？**

答：内存泄漏一般指堆内存的泄漏，当我们向系统申请内存空间时，系统会从堆中为我们分配一块显示的空间，需要我们试用结束后显示地释放该内存空间，以便再次被系统利用，如果我们使用完后没有释放该空间，导致该空间一直被占用而无法再次回收利用，就称为内存泄漏。

   常见地可能发生内存泄漏地情况：

1. 单例模式
 2. File等资源未关闭



**2. 什么是内存溢出？**

答：内存溢出是值程序在申请内存时，没有足够的内存空间供其使用。

累计内存泄漏最终会导致内存溢出。



**3.深拷贝和浅拷贝的区别**

答：浅拷贝时默认提供的拷贝方式，将拷贝对象的值，包括指针原封不动的拷贝到新的对象中，如果拷贝对象中有指向堆内存的指针，那么两个对象中的指针会指向堆内存中的同一片区域，任何一个对象对该值的改变都会影响另外一个对象。 如果对象析构时需要释放该指针，那么会导致同一片内存区域被释放两次而崩溃。

深拷贝是直接在堆内存中重新申请一块内存空间，在此内存空间中存放和拷贝对象相同的值。





**4.左值和右值**

左值：能够取地址的值，赋值运算=左边的值

右值：不能取地址的值，赋值运算=右边的值

左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。

右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：



**5.为什么要使用右值引用**

如果不适用右值引用，系统会将寄存器中的值先拷贝到内存中，在从内存中使用该值，比较浪费时间。



**6.C++面向对象三大特性**

封装、继承、多态



**7.什么是多态**

多态就是类中一个接口的多种实现，父类的指针指向子类的对象，通过在子类中重写父类的方法。在运行时才确定具体调用哪一个方法。



**8.多态的实现方式**

C++中通过虚函数来实现类的多态，通过将类中的方法写为虚函数。 具体的实现方式是在基类和派生类中将同一个函数实现为虚函数，通过虚函数表指针来指向一个虚函数表，表中的数据则为函数指针，这些函数指针指向虚函数的具体实现对应的位置。

普通函数，虚函数，虚函数表都是同一个类的所有对象所共有的，只有虚函数表指针和成员变量是每个对象私有的。每个对象的sizeof大小通常只包括成员变量和虚函数指针。

虚函数实现过程：通过对象内存中的虚函数表指针找到虚函数表，再通过虚函数表找到对应虚函数的具体实现并调用。



**9.纯虚函数**

如果基类中虚函数没有具体的实现 可以设为纯虚函数，如：

```c++
void func(int c){} =0;
```
≠≠≠ ==


**10.为什么析构函数可以是虚函数而构造函数不行**

答：构造函数就是对类对象进行初始化操作，此时对象内还没有虚函数表指针。

​	而析构函数是对对象的内存进行清理释放，对于不同的对象需要用不同的析构方式，如果不将析构函数写成虚函数，将会调用基类的析构函数。



**11.重写和重载**

重写：子类重写父类的方法，函数名、参数、返回值完全一致

重载：相同的函数名，返回值类型或参数个数、参数类型不同





**12. extern、 extern "C", #ifdef __cplusplus**

extern做变量声明：声明extern关键字的全局变量和函数可以跨文件访问

extern "C" 用于C++和C的混合编程，在包含C语言头文件时需要声明：

```c++
extern "C"{
    #include "cExample.h"
}
```

在C++代码中经常会出现如下代码：

```C++
#ifdef __cplusplus 
extern "C" { 
#endif 
 
//一段代码 
 
#ifdef __cplusplus 
} 
#endif
```

__cplusplus时cpp中的自定义宏，如果定义了这个宏表示这是一段cpp代码，上面的代码的含义是：如果这是一段cpp代码，加入extern "C"{}处理其中的代码。



**13. Class 和 Struct**

在C++中struct得到了很大的扩充：

1. struct可以包括成员函数

2. struct可以实现继承

3. struct可以实现多态

区别：

1. 默认的继承访问权限。 class默认的是private, struct默认的是public.

2. 默认访问权限，struct作为数据结构的实现体，它默认的数据访问控制权限是public

   ​							class作为对象的实现体，默认的成员变量的访问权限是private的。



**14.进程和线程的区别**

操作系统的任务：
1. 以多进程形式，允许多个任务同时运行
2. 以多线程实现，允许一个任务分为不同的部分，同时执行。
3. 提供协调机制，一方面防止进程之间的冲突，一方面防止进程之间的多个线程产生冲突

进程是程序的一次执行过程，是一个动态的概念，是系统资源分配和管理的基本单位，每一个进程都有自己的地址空间和一些独立的资源，
每个进程至少有五种基本状态，分别是初始态、就绪态、执行态、等待态、终止态。

线程是CPU调度和分派的基本单位，一个进程内的线程可以共享进程内的所有资源，包括数据空间，代码段、堆、打开的文件，网络句柄等。

线程是进程的一部分，一个进程可以拥有多个线程，而一个线程只能属于一个进程。

进程和线程的根本区别是：进程是资源分配的基本单位，线程是任务调度和执行的基本单位。
进程之间切换的开销较大，因为要切换的上下文环境比较多，包括进程所拥有的全部资源，同一进程的线程之间切换的开销较小，因为它们只切换部分上下文资源，包括PC、运行栈以及一组寄存器等 TLS(Thread Local Storage)。

没有线程的进程可以看成是单线程的，拥有多个线程的进程的执行顺序不是线形的，而是多条线程共同完成的。

线程的缺点： 当进程中的一个线程崩溃时，会导致整个线程崩溃（可能是因为持有资源崩溃， 导致其他线程无法获取资源。）

进程间通讯方式：
- 管道
- 消息队列
- 信号量
- 共享内存

线程间通信方式：

- 共享内存





**15.编译到执行的完整过程**

![](https://pic1.zhimg.com/80/v2-c2703c194fc74c3f82dcf8cd3b971230_1440w.png)

```
.c --> .i
进行预编译，展开和替换宏定义， 展开头文件

.i --> .s
生成汇编代码

.i --> .o
由汇编代码生成可重定位目标文件。

.o -> 可执行文件
由链接器进程重定位，将程序中的符号替换成具体的执行地址。
```

可重定位目标文件的单位是节，可执行文件的单位是段


**17.为什么C++程序一定要有main函数**
答：
main.o 需要和 crt1.o，crti.o 这两个目标文件链接在一起，从而生成可执行文件 main。
你可以使用 readelf 命令来查看 crt1.o 文件的符号表，就会发现里面有一个 main 符号是未定义的，因此需要别的目标文件提供一个定义并且和 crt1.o 链接在一起（
在 crt1.o 中要用到 main 这个符号所代表的地址，而 crt1.o 中的未定义符号 main 在 main.o 中定义了）。
事实上，整个可执行程序真正的入口点是 crt1.o 中的 _start，而 main 函数是被 _start 调用的。



**16.怎么知道一个文件使用了哪些动态库文件**

objdump -x 可执行文件名 | grep NEEDED


	
**17.链表找环**

**18.数组进行奇偶左右划分**

**19.矩阵乘法及优化**





IT Flex Software 相关  

   第一轮：  

   手撕了快排  

   手写了文件读写锁逻辑  

   手写了简单文件系统逻辑（考虑多线程并发）  

   
  

   第二轮：  

   讲了内存管理  

   讲了进程调度  
				
   讲了C++的多态，虚函数  

   讲了一些数据结构，具体忘了  

   然后问了相关的项目  

   最后谈了下自己的代码习惯，有啥特点  

   
  

   在看最后的结果了，也不知道能不能过

https://pic1.zhimg.com/80/v2-c2703c194fc74c3f82dcf8cd3b971230_1440w.png
